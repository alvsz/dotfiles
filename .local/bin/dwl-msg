#!/bin/env python3

import sys
from sys import argv
import json
import os

from pywayland.client import Display
from pywayland.protocol.wayland import WlOutput
# from pywayland.protocol.dwl_ipc_unstable_v2 import ZdwlIpcOutputV2
from pywayland.protocol.dwl_ipc_unstable_v2 import ZdwlIpcManagerV2


outputs = list()
ipc_manager = None
num_tags = 0
layouts = []


class Output(object):
    def __init__(self, wl_output, ipc_output, id):
        global num_tags

        self.wl_output = wl_output
        self.ipc_output = ipc_output

        self.id = str(id)
        self.active = 0

        self.tags = list()

        self.layout = dict(
            new=dict(index=0, symbol=""),
            old=dict())

        self.appid = ""
        self.title = ""

    def handle_active(self, ipc, param):
        self.active = param

    def handle_tag(self, ipc, index, state, clients, focused):
        tag = dict(state=state,
                   clients=clients,
                   index=index,
                   focused=focused, bit_mask=(1 << index))

        if index >= len(self.tags):
            self.tags.append(tag)

        else:
            self.tags[index] = tag

    def handle_layout(self, ipc, index):
        self.layout["old"]["index"] = self.layout["new"]["index"]
        self.layout["new"]["index"] = index

    def handle_title(self, ipc, title):
        self.title = title

    def handle_appid(self, ipc, appid):
        self.appid = appid

    def handle_layout_symbol(self, ipc, symbol):
        self.layout["old"]["symbol"] = self.layout["new"]["symbol"]
        self.layout["new"]["symbol"] = symbol

    def configure(self):
        self.ipc_output.dispatcher["active"] = self.handle_active
        self.ipc_output.dispatcher["tag"] = self.handle_tag
        self.ipc_output.dispatcher["layout"] = self.handle_layout
        self.ipc_output.dispatcher["title"] = self.handle_title
        self.ipc_output.dispatcher["appid"] = self.handle_appid
        self.ipc_output.dispatcher["layout_symbol"] = self.handle_layout_symbol

    def release(self):
        self.ipc_output.destroy()


def handle_num_tags(ipc, param):
    global num_tags
    num_tags = param


def handle_layout_id(ipc, param):
    global layouts
    layouts.append(dict(id=(len(layouts)), icon=param))


def registry_handle_global(registry, id, interface, version):
    global ipc_manager
    global outputs
    global num_tags

    if interface == "zdwl_ipc_manager_v2":
        ipc_manager = registry.bind(id, ZdwlIpcManagerV2, version)

    elif interface == "wl_output" and ipc_manager is not None:
        output = registry.bind(id, WlOutput, version)
        ipc_output = ipc_manager.get_output(output)

        monitor = Output(output, ipc_output, id)

        monitor.configure()

        outputs.append(vars(monitor))


def registry_handle_global_remove(registry, id, interface, version):
    if interface == "wl_output":
        for output in outputs:
            if output["id"] == str(id):
                output.release()
                outputs.remove(output)


def status():
    return json.dumps(outputs, default=lambda o: '<not serializable>')


def error_quit(msg):
    print(msg)
    display.disconnect()
    sys.exit(1)


def follow():
    while display.dispatch(block=True) != -1:
        try:
            print(status())
            sys.stdout.flush()
        except BrokenPipeError:
            devnull = os.open(os.devnull, os.O_WRONLY)
            os.dup2(devnull, sys.stdout.fileno())
            error_quit("broken pipe")


def run_command():
    if len(argv) >= 5:
        selmon = None
        mon = False

        for output in outputs:
            if output["id"] == argv[2]:
                selmon = output["ipc_output"]
                mon = True

        if mon:
            if argv[3] == "set_tags":
                selmon.set_tags(32, 1)

            elif argv[3] == "set_client_tags":
                print("set_client_tags")

            elif argv[3] == "set_layout":
                set_layout(selmon)

        else:
            error_quit(f"{argv[4]} não é um id de monitor válido")
    else:
        error_quit("numero de argumentos invalido")


def set_layout(selmon):
    layout_id = None

    try:
        layout_id = int(argv[4])

    except ValueError:
        error_quit(f"{argv[4]} não é um número inteiro")

    if layout_id >= len(layouts):
        error_quit(f"{argv[4]} é maior que {len(layouts)}")

    elif layout_id < 0:
        error_quit(f"{argv[4]} é menor que 0")

    else:
        selmon.set_layout(layout_id)


if __name__ == '__main__':
    display = Display()
    display.connect()

    registry = display.get_registry()

    registry.dispatcher["global"] = registry_handle_global
    registry.dispatcher["global_remove"] = registry_handle_global_remove

    display.dispatch(block=True)

    if ipc_manager is None:
        error_quit("failed to bind ipc manager")

    ipc_manager.dispatcher["tags"] = handle_num_tags
    ipc_manager.dispatcher["layout"] = handle_layout_id

    display.dispatch(block=True)

    for i in range(num_tags):
        display.dispatch(block=False)

    if argv[1] == "subscribe" or argv[1] == "follow":
        print(status())
        follow()

    elif argv[1] == "get_monitors" or argv[1] == "status":
        print(status())

    elif argv[1] == "get_layouts":
        print(json.dumps(layouts))

    elif argv[1] == "get_tags":
        print(num_tags)

    elif argv[1] == "run_command":
        run_command()

    else:
        error_quit(f"{argv[1]} não é um comando válido")

    display.disconnect()
